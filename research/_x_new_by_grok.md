Understanding Native Resolutions and Descaling in Anime Encoding
Anime production often occurs at resolutions lower than 1080p, such as 720p, 810p, 864p, or 900p, due to workflow efficiencies, hardware limitations, or artistic choices in digital animation. However, Blu-ray releases mandate 1080p (1920x1080) output, necessitating an upscale of the native material. This upscale introduces artifacts like blur, ringing, haloing, or aliasing, depending on the resizing kernel used (e.g., bilinear for soft results or sharp bicubic variants for enhanced edges). Descaling reverses this process by downscaling to the estimated native resolution using an inverse kernel, potentially yielding sharper lineart, reduced artifacts, and smaller file sizes for encodes, as the viewer’s player can handle the upscale with superior algorithms like those in madVR. 2 This is particularly beneficial for clean, high-quality sources like Blu-rays, but less so for noisy simulcasts or heavily post-processed content, where descaling might exacerbate issues. 1
Descaling is not always perfect or applicable. Consumer sources are lossy (e.g., compressed Blu-rays), so exact replication of the original master is impossible, leading to minor discrepancies even with correct parameters. 1 If no clear low-error matches emerge, traditional resizing (e.g., Spline36) is safer to avoid destructive aliasing or ringing. 3 Benefits include better lineart preservation and artifact reduction, but risks arise from mixed resolutions (e.g., 1080p credits overlaid on lower-res content) or incorrect kernel guesses, which can introduce jagged edges or oversharpening. 2
Finding Native Resolutions
Determining the native resolution is crucial; incorrect guesses destroy details. Methods include:
	•	Visual Inspection and Databases: Examine frames for aliasing or jagged edges after inverse scaling. Databases like Anibin (a Japanese blog analyzing anime resolutions via Kanji/Kana titles from sites like MyAnimeList) provide estimates, e.g., Non Non Biyori Repeat at 846p. 2 Odd “halfway” resolutions (e.g., Kyoto Animation’s 955.5p) often stem from scaling errors, such as upscaling to 1088p (a common MPEG-2 multiple) instead of 1080p, then cropping 8 pixels, resulting in fractional losses (e.g., from 1712x963 to ~1699x956). 6 This affects higher-than-720p productions more, as 720p sources scale cleanly without such pitfalls.
	•	Automated Tools: Several scripts automate detection by descaling, re-upscaling, and measuring error (difference between original and reconstructed frame). Lower error indicates a match.
	◦	getnative (Infiziert90): A Python script using VapourSynth to test resolutions (default 500-1000p) and kernels. It plots relative error graphs; spikes/dips signal natives (e.g., clear dip at 720p for bilinear). Works best on bright, clean frames without grain or VFX. Supports bicubic (b/c params), lanczos (taps), bilinear; modes like “all” test common kernels. Installation via pip; requires VapourSynth, descale, etc. Cannot detect native 1080p due to no-descale logic. 7 Example: python getnative.py image.png -k bilinear outputs graph and guess (e.g., 873p for bicubic b=0.33 c=0.33).
	◦	resdet (0x09): A C-based CLI/library detecting upscaling via frequency domain analysis (Discrete Cosine Transform identifies zero-crossings from traditional resamplers). Excels on clear images; struggles with compression artifacts or neural upscalers. Supports multi-frame video analysis (e.g., y4m from FFmpeg). Best in original colorspace (e.g., linear RGB). Example: resdet resized.png outputs best guess (e.g., 512x512 from 768x768 upscale) with confidence percentages. Standalone library for integration; no native 1080p detection. 4 
	◦	GetFnative (YomikoR): Focuses on fractional resolutions (e.g., 830.77p), searching intervals (e.g., 820-840 in 0.1 steps) for src_height after assuming integer base (e.g., parity-even 864p). Handles cropping/letterboxing; outputs for descale args. Quick mode (getfnativeq) tests presets. Inspired by Anibin; useful for odd sizes from 1088p mishaps. Example: python -m getfnative script.vpy -bh 864 -f 1001 searches fractionals around 864p. 8 
	◦	getfscaler (Jaded-Encoding-Thaumaturgy): Rewrite of getscaler with fractional support via vsjet; tests kernels (professional + point); handles cross-conversion, one-dimensional scaling. Warns on high errors; adds post-filtering for dither/dirty edges. Not conclusive—trust eyes. Example: python getfscaler input.mkv -nh 719.8 -bh 720 for fractional native. 5 
Tool Comparison: getnative/resdet suit integer natives; GetFnative/getfscaler excel at fractionals from crop errors. All require clean frames; combine with visual checks (e.g., point-resize magnification for aliasing). 3 resdet’s spectral approach complements error-based methods but fails on modern AI upscalers.
Kernels and Implementation
Common kernels:
	•	Bilinear: Soft; inverse via Debilinear. Example (VapourSynth): core.fmtc.resample(clip, 1280, 720, kernel='bilinear', invks=True). 2 
	•	Bicubic: Parametric (b/c; e.g., Mitchell-Netravali b=1/3 c=1/3; Catmull-Rom b=0 c=0.5). Sharp variants add ringing. 1 
	•	Others: Lanczos (taps=3+), Spline36 (neutral sharp).
In scripts like descale plugin, test via descale-rescale-error loop. For chroma (4:2:0 subsampled), upscale separately to 4:4:4 for better color retention. 2 Example (VapourSynth, bilinear 720p native):
y = core.std.ShufflePlanes(src, 0, vs.GRAY)
u = core.std.ShufflePlanes(src, 1, vs.GRAY)
v = core.std.ShufflePlanes(src, 2, vs.GRAY)
y = core.fmtc.resample(y, 1280, 720, kernel='bilinear', invks=True)
u = core.fmtc.resample(u, 1280, 720, kernel='spline36', sx=0.25)
v = core.fmtc.resample(v, 1280, 720, kernel='spline36', sx=0.25)
out = core.std.ShufflePlanes([y, u, v], [0,0,0], vs.YUV)
Handling Artifacts and Mixed Content
Credits/overlays often native 1080p; mask them to avoid haloing (e.g., MaskDetail in VapourSynth detects differences, merges with downscale like blackmanminlobe). 2 Wrappers like kagefunc.inverse_scale automate this: descaled = kgf.inverse_scale(src, height=878, kernel='bicubic', b=0, c=1/2, mask_detail=True). 1 For bad results, apply AA like EEDI3, but manual verification is key—descaling isn’t magic. 1
Fractionals arise from 1080/1088 mismatches, common in HV1280+ (e.g., 955.5p from Kyoto Ani 1712x963 cropped post-1088 upscale). 6 Tools like GetFnative address this via parity-aware searches.
In summary, descaling optimizes encodes but demands accurate natives via tools/databases. Always validate visually; combine methods for robustness. The unfinished PDF (kbz12.pdf) likely expands on kageru’s legacy guide but was inaccessible here. 0


